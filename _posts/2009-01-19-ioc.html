---
layout: post
title: "Введение в IoC"
date: '2009-01-19T22:03:00.004+03:00'
author: "Станислав Выщепан"
tags:
- DL
- IoC
- DI
- Unity
- ".NET"
- IoC-контейнер
modified_time: '2009-01-20T00:07:32.727+03:00'
blogger_id: tag:blogger.com,1999:blog-1302241583051203640.post-8568699465278935196
blogger_orig_url: http://blog.gandjustas.ru/2009/01/ioc.html
redirect_from: /2009/01/ioc.html
---

(<a href="http://www.rsdn.ru/forum/message/3243723.1.aspx">Пост на RSDN</a>)
<p>Есть класс A и зависит от от класса B (использует его).
</p>
Например так:
<pre name="code" class="c-sharp">
public class A
{
   B b = new B();
   void foo()
   { 
      //используем b
   }
}

public class B
{
    ...
}
</pre>
<p>
В этом коде существует несколько проблем.
<br/>1)Невозможно тестировать класс A в отрыве от B. Если B работает с БД, то для тестов A вам понадобится база.
<br/>2)Временем жизни объекта B управляет А, нельзя например использовать один и тот же объект B в разных местах.
</p>

Чтобы победить это нам сначало надо выделить интерфейс B и назвать его IB.
<pre name="code" class="c-sharp">
public interface IB
{
    ...
}

public class A
{
    IB b = new B();    
  
    void foo()  
    {    
        //используем b  
    }
}

public class B:IB
{
    ...
}
</pre>
Но ни одну из наших проблем это не решило.

<p>Теперь можно применить паттерн Service Locator. Суть этого паттерна состоит в том что имеем фабричный метод который по идентификатору возвращает нужную реализацию интерфейса. В .NET есть IServiceProvider с одном методом GetService, которому параметром передается тип.</p>

Предположим что мы сделали хорошую реализацию IServiceProvider и у нас получился такой код
<pre name="code" class="c-sharp">
public interface IB
{
    ...
}
public class A
{
    //serviceLocator - реалзиация IServiceProvider
    //которая по типу IB возвращает B
    IB b = (IB)serviceLocator.GetService(typeof(IB)); 
   
    void foo()  
    {
        //используем b
    }
}

public class B:IB
{
    ...
}
</pre>
<p>Теперь временем жизни B управляет serviceLocator, A не знает о классе B. Можно через serviceLocator подпихнуть любую реализацию IB.<br/>
Этот подход называет <span style="font-weight:bold;">Dependency Lookup</span> — поиск зависимостей, это один из вариантов подхода IoC.</p>

<p>Но у нас появилась зависимость от serviceLocator, теперь хоть тестировать A без класса B возможно, но это потребует настройки локатора (возможно совсем нетривиальной).</p>

Если подойти с другой стороны, то можно сделать так чтобы класс A не искал зависимости сам, а получал их извне. Например через конструктор, свойство или метод.
<pre name="code" class="c-sharp">
public interface IB
{
    ...
}

public class A
{    
    IB b;    
    
    //Например так  
    public A(IB b)
    {
        this.b = b;
    }

    //Или так  
    public IB B { {get {return b;} set {b = value;}}  

    //Или так  
    public void SetB(IB b)
    {
        this.b = b;
    }  
    
    void foo()
    {    
        //используем b
    }
}

public class B:IB
{
    ...
}
</pre>
Тогда вызывающий код дожен выгядеть примерно так
<pre name="code" class="c-sharp">
...
var a = new A(new B());
...
</pre>

<p>Теперь у нас A не зависит ни от чего, а все зависимости можно передать например через конструктор, что значительно облегчает тестирование A.<br/>
Этот подход называется <span style="font-weight:bold;">Dependency Injection</span> — инъекция зависимостей, это другой вариант IoC.</p>

<p>Но в большем масштабе проблемы не решает, только перемещает её на уровень выше, то есть все зависимости перемещаются в вызывающий код.</p>

<p>Если такой подход применить во всей программе, то в итоге метод main (или другая точка входа) будет выглядеть так:
<pre name="code" class="c-sharp">new Program(new A(new B(new C(), new D()), new E()......)</pre>
И это мы еще не рассматривали управление временем жизни объектов.</p>

<p>На помощь нам приходят IoC-контейнеры.<br/>
Сами IoC-контейнеры похожи на ServiceLocator, только делают чуть больше работы.<br/> При запросе объекта какого-то типа у контейнера он решает объект какого типа вернуть. Для каждого типа, зарегистрированного в IoC-контейнере, есть карта зависимостей, то есть описание какие параметры надо передавать в конструктор, каким свойствам надо присваивать и какие методы вызывать чтобы инъектировать зависимости в объект. Карта зависимостей задается внешне или получается с помощью рефлексии.<br/>
Кроме того контейнер содержит ассоциации для какого запрошенного идентификатора объект какого типа надо вернуть. В качестве идентификатора чаще всего используется сам тип. Для каждой зависимости запрошенного объекта, контейнер создает дургой объект у которого тоже могут быть зависимости, для них эта операция вызывается рекурсивно.<br>
В принципе контейнер не обязан каждый раз создавать объект, он может управлять его временем жизни.</p>

<p>Хороший IoC контейнер должен возможности чтобы код выше можно было переписать так:
<pre name="code" class="c-sharp">container.Resolve&lt;program>();</pre>
А также потребуется где-то задать параметры контейнеру, чтобы он по запросу объекта типа IB возвращал объект типа B, для IA возвращал A и так далее.
<br/>
Обычно параметры контейнера можно задавать как в коде, так и во внешнем конфигурационном файле.</p>

<p>Кроме того IoC-контейнер можно использовать как Service Locator, но такого надо избегать.</p>


<p>Для .NET существует множество контейнеров. От MS — <a href="http://www.codeplex.com/unity">Unity</a>, даже <a href="http://msdn.microsoft.com/en-us/library/dd362339.aspx">версия для Silverlight</a> уже появилась, <a href="http://code.google.com/p/autofac/">autofac</a>, <a href="http://www.castleproject.org/container/">Castle Windsor</a>, <a href="http://structuremap.sourceforge.net/">StructureMap</a> и <a href="http://www.springframework.net/">Spring.NET</a>.
Spring.NET — клон java библиотеки со всеми вытекающими. Куча конфигов в XML, огромное число классов в библиотеке, слабое использование возможностей .NET, лично меня от него воротит после использования достаточно легковесного unity.</p>
<br/>
<p>Кроме того MS ведет разработку библиотеки <a href="http://www.codeplex.com/MEF">MEF</a>. В ней применяются принципы IoC, но для более крупных компонент, а также возможности менять набор компонент в Runtime. MEF будет в составе .NET 4.0</p>
