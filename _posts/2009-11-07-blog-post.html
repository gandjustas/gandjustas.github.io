---
layout: post
title: "Типы, подтипы и вариантность."
date: '2009-11-07T18:24:00.001+03:00'
author: "Станислав Выщепан"
tags: 
modified_time: '2009-11-07T18:24:43.100+03:00'
blogger_id: tag:blogger.com,1999:blog-1302241583051203640.post-179745883676786801
blogger_orig_url: http://blog.gandjustas.ru/2009/11/blog-post.html
---

<p>Скоро (22 марта 2010)&#160; выходит Visual Studio 2010, которая будет поддерживать C# 4.0 Больше всего вопросов возникает из-за новой фичи языка – ко- и контр- вариантности. Попытаюсь дать объяснение на человеческом языке.</p>  <p>В любой системе типов существуют отношения между типами. Нас интересует отношение типа-подтип. Для типов A и B будем обозначать A :&gt; B, если A является <em>подтипом</em> B (B является <em>супертипом</em> A). Если A является подтипом B, то везде где в программе требуется значение типа B можно подставлять значение типа A без каких-либо дополнительных конструкций.</p>  <p>Например во многих языках тип целых чисел является подтипом вещественных. В ОО-языках такое отношение реализуется за счет <em>наследования</em>. Если A является наследником B, то A является подтипом B.</p>  <p>Тут стоит вспомнить принцип LSP (принцип подстановки Барбары Лисков). Он ошибочно приписывается к ООП, хотя имеет к нему весьма отдаленное отношение. Принцип гласит что<em> если A :&gt; B, то любое утверждение для B должно быть верно для A</em>. Выполнение этого принципа означает что поведение программы при подстановке значения типа A там где требуется B не изменится.</p>  <p>Но это я ушел в сторону.&#160; Когда у нас чистый ООП язык (как smalltalk) тогда отношения типов-подтипов исчерпываются наследованием, которое создает довольно простые отношения. Все становится сложно когда появляются <em>типы, параметризуемые другими типами</em> <em>(обобщенные типы)</em>.</p>  <p>Будем обозначать обобщенный типа как T&lt;`a&gt;, где `a – параметр типа. Конкретный тип при подстановке параметра будем обозначать T&lt;A&gt;, где A – какой-то тип. Для иллюстраций нам понадобится обобщенный тип с одним параметром, хотя типов-параметром может быть много.</p>  <p>Тут возникает интересный вопрос. Если A :&gt; B, то как связаны T&lt;A&gt; и&#160; T&lt;B&gt; ?</p>  <p>Тип T&lt;`a&gt; называется <em>ковариантными, </em>если для A :&gt; B выполняется T&lt;A&gt; :&gt; T&lt;B&gt;, и <em>контрвариантым, </em>если A :&gt; B выполняется T&lt;B&gt; :&gt; T&lt;A&gt;,     <br />если же T&lt;A&gt; и&#160; T&lt;B&gt; не связаны никакими отношениями, то такой тип называет <em>инвариантым.</em></p>  <p>Примеры.</p>  <p>1)IEnumerable&lt;T&gt;. Например если Apple унаследован от Fruit (то есть Apple :&gt; Fruit), то вполне резонно было бы иметь IEnumerable&lt;Apple&gt; :&gt; IEnumerable&lt;Fruit&gt;. Действительно, в .NET 4 IEnumerable&lt;T&gt; является ковариантым и имеет сигнатуру <strong>IEnumerable&lt;out T&gt;.</strong></p>  <p>2)Action&lt;T&gt;. Например есть метод void Eat(Fruit f), он имеет тип Action&lt;Fruit&gt;, и у нас Apple :&gt; Fruit. Тогда было бы хорошо иметь Action&lt;Fuit&gt; :&gt; Action&lt;Apple&gt;, то есть если нам куда-то понадобится передавать Action&lt;Apple&gt; мы могли бы туда передать Action&lt;Fruit&gt;. В .NET 4 Action&lt;T&gt; является конртвариантным и имеет сигнатуру <strong>Action&lt;in T&gt;</strong>.</p>  <h5>Магические слова in и out.</h5>  <p>Такие модификаторы были выбраны неслучайно. Ко- и контр- вариантность может приводить к ошибкам при неумелом использовании. Например массивы в .NET 2 и выше являются ковариантными. То есть там где требуется Fruit[] можно передать Apple[]. Но программист может внутри метода, обрабатывающего Fruit[] присвоить элементу массива значение типа Banana. Что приведет к runtime error.</p>  <p>Чтобы ковариантность была безопасной необходимо чтобы ковариантные типы-аргументы были<em> только в выходных</em> значениях методов. То есть для T&lt;out `a&gt; можно писать методы возвращающие `a или имеющие out-параметры типа `a. также могут быть get-only свойства, возвращающие `a.</p>  <p>Аналогично для контрвариантного T&lt;in `a&gt; параметры типа `a могут быть только во <em>входных </em>параметрах методов.</p>  <h5>Темная сторона силы.</h5>  <p>Ко – и контр- вариантность типов в сочетании с наследованием могут давать довольно сложные графы отношений типов, в том числе имеющие замкнутые направленные контуры (попробуйте сами такое сделать), которые срывают башню алгоритмам вычисления отношений типов.</p>  <p>PS. В C# отношение тип-подтип проверяется оператором is.</p>  