---
layout: post
title: "Безопасность приложений SharePoint 2013"
date: '2013-12-05T10:00:00.000+04:00'
author: "Станислав Выщепан"
tags:
- SharePoint 2013
- sp2013
- apps
- SharePoint
modified_time: '2013-12-05T10:00:09.994+04:00'
thumbnail: http://lh4.ggpht.com/-YbrQIjklCHk/Up_A7upuLuI/AAAAAAAAAYc/u8PyIxKH5TY/s72-c/image_thumb%25255B27%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-1302241583051203640.post-11486312228286047
blogger_orig_url: http://blog.gandjustas.ru/2013/12/sharepoint-apps-auth-permissions.html
redirect_from: /2013/12/sharepoint-apps-auth-permissions.html
category: SharePoint 2013
---

<p>Система разрешений в новой архитектуре <em>приложений</em> в SharePoint 2013 (о которых <a href="http://gandjustas.blogspot.com/2013/12/sharepoint-apps-intro.html" target="_blank">я писал ранее</a>) до сих пор вызывает много вопросов. Попробую прояснить некоторые из них:</p> <h3>Введение</h3> <p>Когда вы создаете <em>решение</em> код работает под учетной и с правами того пользователя, который этот код запустил. Это сильно повышает безопасность платформы, но усложняет написание кода. </p> <p>В FullTrust возможно повышение привилегий путем создания объекта SPSite с токеном более привилегированного пользователя (<a href="http://msdn.microsoft.com/ru-ru/library/microsoft.sharepoint.spusertoken.systemaccount.aspx" target="_blank">SPUserToken.SystemAccount</a>). Код с повышенными привилегиями может делать всё (вообще всё). Поэтому любое <em>решение</em> или опасно, или почти бесполезно. Еще одна проблема повышения привилегий – невозможно отследить какой пользователь и какие действия вызвали изменения, потому что везде будет один и тот же пользователь даже для разных <em>решений</em>.</p> <h3>App Principals</h3> <p>Для решения проблем обозначенных выше, приложения решили сделать участниками системы безопасности (principal), также как и пользователей. Это означает что у каждого приложения есть свой App Principal, которому назначаются права. </p> <p>Пользователь сопоставляется со своим principal в процессе аутентификации, то есть при передаче логина\пароля (или токена) от пользователя к SharePoint. </p> <p>А как же происходит аутентификация приложений, ведь нету логинов и паролей у приложений...</p> <p>Этот процесс описывает простая схема:</p> <p><a href="http://lh4.ggpht.com/-aDb-WBUKRmo/Up_A63sJTqI/AAAAAAAAAYU/kKF_vZnFJao/s1600-h/image%25255B29%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh4.ggpht.com/-YbrQIjklCHk/Up_A7upuLuI/AAAAAAAAAYc/u8PyIxKH5TY/image_thumb%25255B27%25255D.png?imgmax=800" width="560" height="410"></a></p> <p>Схема не совсем точная, но в общем описывает процесс правильно.</p> <p>Если не вдаваться в детали, то выполняются такие условия:</p> <ol> <li>Если пользователь аутентифицирован и происходит запрос к AppWeb, то используется App Principal + User Principal (<strong>внутренняя</strong> аутентификация).</li> <li>Если пользователь <strong>не</strong> аутентифицирован, но в запросе указан <em>access token</em> (<strong>внешняя</strong> аутентификация), то</li> <ul> <li>Если в <em>access token</em> указан user identity, то то используется App Principal + User Principal.</li> <li>Если в <em>access token</em> <strong>не</strong> указан user identity, то то используется App Principal&nbsp; с App Only-Policy.</li></ul> <li>Во всех остальных случаях аутентификация для приложения не происходит.</li></ol> <h3>Внутренняя аутентификация</h3> <p>Скриншот манифеста свежесозданного SharePoint-hosted app, обратите внимание на элемент AppPrincipal.</p> <p><a href="http://lh3.ggpht.com/-FDAF3Tk1d0I/Up_A8IdX2GI/AAAAAAAAAYk/-aMYGFEaWnE/s1600-h/image%25255B30%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh6.ggpht.com/-yz2oD83dCTk/Up_A88QblTI/AAAAAAAAAYs/68y2FQKrf7c/image_thumb%25255B28%25255D.png?imgmax=800" width="560" height="318"></a></p> <p>Внутренняя аутентификация называется так, потому что все процессы аутентификации приложения происходят <em>внутри</em> SharePoint. Вам для этого не надо ничего писал и\или настраивать (только DNS для AppWeb).</p> <p>Внутренняя аутентификация используется именно для SharePoint-hosted app и JavaScript кода. В других случаях сложно повторить условия для внутренней аутентификации. Чтобы нельзя было обойти внутреннюю аутентификацию и проверку прав приложения AppWeb создается на уникальном домене. Это позволяет блокировать JavaScipt обращения, используя same origin policy, которая встроена в браузер.</p> <p>Есть еще возможность размещать клиентский JavaScript внешнем сайте, и он будут обращаться к AppWeb и будет работать аутентификация приложения. </p> <h3>Внешняя аутентификация</h3> <p>Если же поменять тип приложения на Provider-hosted , то можно увидеть такой манифест:</p> <p><a href="http://lh6.ggpht.com/-RKrJ5krVh7o/Up_A9T89K-I/AAAAAAAAAY0/ZzmQH8nr-XM/s1600-h/image%25255B31%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh5.ggpht.com/-QJE0chMiK6M/Up_A-LFVeEI/AAAAAAAAAY8/ZrR6KMV7pVE/image_thumb%25255B29%25255D.png?imgmax=800" width="560" height="319"></a></p> <p>В элементе AppPrincipal появилось RemoteWebApplication. ClientId="*" заменяется на идентификатор приложения при отладке или публикации.</p> <p>access token должен содержать идентификатор приложения, чтобы SharePoint мог привязать AppPrincipal. Для формирования Access token используется oauth или s2s trust. Оба доступны только в серверном коде внешнего приложения и не доступны в клиентском JavaScript.</p> <p>Основная проблема в том, что нельзя одновременно указать внутреннюю и внешнюю аутентификацию. То есть нормально обращаться к SharePoint сможет или серверный код на внешнем сайте или JavaScript на AppWeb. Учитывая что многие стандартные компоненты SharePoint используют JSOM, то они не будут работать при внешней аутентификации. Это делает AppWeb почти бесполезным для Provider-hosted приложений.</p> <h3>OAuth</h3> <p>OAuth это протокол (правильнее сказать фреймворк), который описывает протоколы и сценарии аутентификации приложений в вебе. В Office 365 используется схема с тремя действующими лицами:</p> <ul> <li>Приложение</li> <li>Access Control Service (ACS)</li> <li>SharePoint</li></ul> <p>SharePoint и приложение доверяют ACS, SharePoint <strong>не</strong> доверяет приложению напрямую (и правильно делает :) ).</p> <p>Процесс аутентификации выглядит так:</p> <ol> <li>Пользователь нажимает на плитку приложения.</li> <li>SharePoint запрашивает у ACS так называемый <em>context token </em>по <em>ClientId</em> приложения и отдает <em>context token</em> клиенту (браузеру). <em>Context token</em> подписан с помощью ClientSecret, который известен ACS и приложению.</li> <li>Браузер делает <strong>POST запрос</strong> на адрес приложения и передает <em>context token</em>.</li> <li>Приложение проверяет <em>context token</em> с помощью <em>ClientSecret</em> и извлекает <em>refresh token</em>.</li> <li>Далее по <em>refresh token</em> приложение может получить <em>access token</em> от ACS и обращаться с ним к SharePoint.</li></ol> <p>Описание на MSDN: <a title="http://msdn.microsoft.com/en-us/library/office/fp142382.aspx" href="http://msdn.microsoft.com/en-us/library/office/fp142382.aspx">http://msdn.microsoft.com/en-us/library/office/fp142382.aspx</a></p> <p>Параметры <em>ClientId</em> и <em>ClientSecret</em> вы получаете при регистрации в Office Store или при добавлении нового app principal на странице /_layouts/15/appregnew.aspx.</p> <p>Важные моменты:</p> <ul> <li>&nbsp;<em>Context token</em> передается приложению POST запросом. При переходе н другую страницу в приложении <em>context token </em>не сохранится. Само приложение должно это делать. В Visual Studio 2013 включили класс SharePointContext, который управляет сохранением токенов в сессии.</li> <li>Из-за использования POST нельзя реализовать OAuth на клиентском JavaScript. Даже не пытайтесь.</li> <li>SharePoint и ACS напрямую не обращается к вашему приложению, кроме случаев использования Remote Event Receiver или Workflow. Поэтому SharePoint абсолютно все равно где и на чем работает ваше приложение. Это например позволяет отлаживать облачные приложения на локальной машине.</li></ul> <p>OAuth полагается на SSL, так как все токены передаются незащищенными от перехвата. Любое приложение SharePoint для Office 365 должно иметь SSL сертификат.</p> <p>Как я <a href="http://gandjustas.blogspot.com/2013/12/sharepoint-apps-intro.html" target="_blank">писал ранее</a>, в onprem по-умолчанию не работает OAuth и используется его расширение S2STrust. Можно интегрировать onprem ферму с тенантом office365, тогда появится возможность устанавливать provider-hosted приложения из маркета. Подробнее тут: <a title="http://msdn.microsoft.com/en-us/library/office/dn155905.aspx" href="http://msdn.microsoft.com/en-us/library/office/dn155905.aspx">http://msdn.microsoft.com/en-us/library/office/dn155905.aspx</a></p> <h3>S2S Trust</h3> <p>В onprem варианте вместо “трехногого” OAuth используется “двуногий” вариант, называемый Server-to-Server Trust. Суть в том что SharePoint доверяет серверу приложения. Для установления факта доверия в SharePoint должен быть добавлен Trusted Token Issuer, а это требует сертификата. Приложение этим сертификатом подписывает запросы на получение access token пользователя.</p> <p>В “двуногой” схеме никаких <em>context token</em> и <em>refresh token</em> не используется. Приложение должно само аутентифицировать пользователя и передавать данные о текущем пользователе в SharePont. Да, это позволяет приложению притворяться любым пользователем.</p> <p>Такие приложения называются приложением с высоким доверием (High trust), в отличие от full trust права приложения все-таки ограничиваются. </p> <p>Подробнее тут: <a title="http://msdn.microsoft.com/en-us/library/office/fp179901.aspx" href="http://msdn.microsoft.com/en-us/library/office/fp179901.aspx">http://msdn.microsoft.com/en-us/library/office/fp179901.aspx</a></p> <h3>Права приложений</h3>   <p>Независимо от того, какой вид аутентификации приложения используется,&nbsp; приложению назначаются разрешения. Права приложения отличаются от прав пользователей:</p> <ul> <li>Требуемые права задаются в манифесте.</li> <li>Права приложению даются при установке по принципу “все или ничего”.</li> <li>Права приложений не используют иерархию объектов SharePoint.</li></ul> <p>Вот так выглядит запрос прав манифесте, указываются области и требуемые права:</p> <p><a href="http://lh4.ggpht.com/-MXe1NTAn-4A/Up_A-pECUeI/AAAAAAAAAZE/PxrCM3dsB2w/s1600-h/image%25255B32%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh3.ggpht.com/-bfh473W9c2k/Up_A_HN3yQI/AAAAAAAAAZM/RGtvAqJbBEQ/image_thumb%25255B30%25255D.png?imgmax=800" width="560" height="104"></a></p> <p>Полный список возможных разрешений: <a title="http://msdn.microsoft.com/en-us/library/office/fp142383.aspx" href="http://msdn.microsoft.com/en-us/library/office/fp142383.aspx">http://msdn.microsoft.com/en-us/library/office/fp142383.aspx</a></p> <p>Для вычисления эффективных разрешений права пользователя и права приложения пересекаются. Porvider-hosted app может также получить app-only access token, если в манифесте приложения было указано app-only policy.</p> <p><a href="http://lh3.ggpht.com/-ivTsN2p3Ngc/Up_A_yOw_VI/AAAAAAAAAZU/8XVo-PMscFI/s1600-h/image%25255B33%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="http://lh3.ggpht.com/-lK32Lh2XQ7A/Up_BAfSerYI/AAAAAAAAAZc/Db8-U63ZBl0/image_thumb%25255B31%25255D.png?imgmax=800" width="560" height="103"></a></p> <p>Надо учитывать что все это работает только для CSOM и REST вызовов. Обычные (устаревшие) веб-сервисы не поддерживают аутентификацию с помощью access token.</p> <p>Права – основной источник проблем для приложений. Если вы дадите приложению недостаточно прав, то ошибки буду очень непонятными. Иногда сочетание прав для некоторой операции крайне неочевидно, например:</p> <ul> <li>Публикация в социальную ленту требует Social Write, Tenant Write, User Profiles Read, если не дадите одно из них вам скажут “Social list not found” или что-то в этом роде.</li> <li>Добавление типов контента на подсайт требует sitecollection read, хотя если вы будете тестировать приложение на корневом сайте, то прав web manage может хватить.</li></ul> <p>Есть еще возможность запрашивать права “на лету”, но это тема для отдельной статьи. Пока можете прочитать описание на MSDN: <a title="http://msdn.microsoft.com/en-us/library/office/jj687470.aspx" href="http://msdn.microsoft.com/en-us/library/office/jj687470.aspx">http://msdn.microsoft.com/en-us/library/office/jj687470.aspx</a></p> <h3>Заключение</h3> <p>Большая часть сложностей аутентификации приложений скрыто от глаз программистов, с помощью внутренних механизмов SharePoint и классов хелперов SharePointContext и TokenHelper. Тем не менее надо хорошо понимать внутренние механизмы, особенно разграничения доступа, чтобы успешно создавать приложения.</p> <p>С появлением модели apps нагрузка на SharePoint разработчиков сильно возросла, надо изучать много новых технологий и подходов, чтобы эффективно применять возможности платформы.</p> <p>Изучайте, развивайтесь.</p>  
