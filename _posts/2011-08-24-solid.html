---
layout: post
title: SOLID
date: '2011-08-24T10:00:00.005+04:00'
author: "Станислав Выщепан"
tags:
- "архитектура"
- SOLID
- "ООП"
modified_time: '2011-08-24T10:00:03.174+04:00'
blogger_id: tag:blogger.com,1999:blog-1302241583051203640.post-797666860667933456
blogger_orig_url: http://blog.gandjustas.ru/2011/08/solid.html
---

<p>Эта аббревиатура является самой известной (после ООП), она говорит нам о 5 принципах “хорошего дизайна ПО”. При этом является самой бесполезной, потому что однозначно никто не может обозначить критерий для того или иного принципа. Часто на форумах приходится видеть споры о том у кого программа SOLIDнее. </p><p>Про SOLID пишут часто и много, но большинство пишущих не читали или мало читали <a href="http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf" target="_blank">первоисточник</a> (признайтесь, вы читали?). Автор аббревиатуры <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)" target="_blank">SOLID</a> - <a href="http://en.wikipedia.org/wiki/Robert_C._Martin" target="_blank">Роберт Мартин</a>, он придумал саму аббревиатуру и <em>описал</em> 5 принципов. На самом деле он описал больше, но звучных буквосочетаний не придумал, многие вещи остались забытыми. Заметьте что Мартин именно описал принципы, он не является их автором. Зачастую объяснения <strike>на пальцах</strike> на примерах сложно перенести в свой код.</p><a name='more'></a>  <br />
<cut title="Читать дальше..."><br />
<h4>Who is mister SOLID?</h4><p>Аббревиатура (длинное и неприятное слово) SOLID состоит из:</p><ul><li><strong>Single Responsibility Principle </strong>(<em>SRP</em>) – принцип единственной отвественности </li>
<li><strong>Open\Close Principle</strong> (<em>OCP</em>) – принцип открытости\закрытости </li>
<li><strong>Liskov Substitution Principle</strong> (<em>LSP</em>) – принцип подстановки Лисков (это фамилия) </li>
<li><strong>Interface Segregation Principle</strong> (<em>ISP</em>) – принцип изоляции интерфейсов </li>
<li><strong>Dependency Inversion Principle</strong> (<em>DIP</em>) – принцип инверсии зависимостей </li>
</ul><p>Далее буду пользоваться только акронимами, указанными в скобках.</p><h4>Критика</h4><p>Как связаны между собой вышеуказанные принципы никто не говорит, какой из них важнее, а какой нет – тоже никто не в курсе. </p><p>Разберем по отдельности все 5 принципов, для описания буду брать <a href="http://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" target="_blank">из википедии</a>. Вероятнее всего именно это описание найдет человек.</p><h5>SRP</h5><blockquote><p>На каждый объект должна быть возложена одна единственная обязанность.</p></blockquote><p>Первое же определение взрывает мозг. Что такое <em>обязанность</em>? Мартин определяет обязанность как <em>причину изменения</em>. Стало понятнее? Мне не очень.</p><h5>OCP</h5><blockquote><p>Программные сущности должны быть открыты для расширения, но закрыты для изменения.</p></blockquote><p>Это как вообще? Открыты для расширения – еще куда ни шло, а что значит закрыты для изменения? Скомпилированный код и так поменять нельзя, а если правятся исходники, то какая разница?</p><h5>LSP</h5><blockquote><p>Объекты в программе могут быть заменены их наследниками без изменения свойств программы.</p></blockquote><p>Тут немного лучше, потому что принцип LSP предельно формален, про него подробнее напишу ниже.</p><h5>ISP</h5><blockquote><p>Много специализированных интерфейсов лучше, чем один универсальный.</p></blockquote><p>Это Мартин&#160; решил поиграть в Капитана Очевидность.</p><h5>DIP</h5><blockquote><p>Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</p></blockquote><p>Это просто бред, написанный для красного словца. Если все зависит от абстракций, то как понять где модули верхнего уровня, а где нижнего?</p><p>У Мартина, кстати, не такое определение.</p><h4>Терминология</h4><p>Чтобы навести формализм во всей этой кухне необходимо ввести определения. большинство горячих споров происходят как раз из-за разных определений.</p><h5>Итак определения</h5><p><em>Интерфейс – </em>некоторый набор функций (их параметров и возвращаемых значений), с помощью которого одна часть программы обращается к другой.</p><p><em>Контракт </em>– надмножество интерфейса, описывающее также поведение функций, ограничения на входные\выходные параметры, инварианты, последовательность вызовов итд. Контракт обычно присутствует в программе неявно, но есть средства, позволяющие часть его описать явно. Например навороченные системы типов как в haskell, внешние средства вроде Code Contracts в .NET. <em>Даже если контракт не определен явно, то в программе он неявно присутствует.</em> </p><p><em>Абстрактный интерфейс</em> – некоторый тип данных,состоящий из набора методов без реализации. Всегда соответствует некоторому <em>интерфейсу.</em></p><p><em>Класс</em> – некоторый тип данных, который состоит из данных и методов. Классы могут наследоваться один от другого, могут реализовывать несколько <em>абстрактных интерфейсов.</em> Класс всегда имеет некоторый <em>интерфейс</em> и <em>контракт</em>, зачастую больше одного.<em>&#160;</em></p><p><em>Модуль</em> – некоторое множество функций и, возможно, данных, объединенные для решения задачи. Модулем могут быть как <em>классы</em> в ОО-языках, так и другие средства группирования кода. Модуль также имеет <em>интерфейс</em> и <em>контракт</em>, скорее всего один.</p><h4>Принципы</h4><p>Для начала стоит сказать что многие принципы не являются прерогативой ООП, а применимы для широкого класса парадигм.</p><h5>Начнем с <em>SRP</em></h5><blockquote><p>Если часть некоторого <em>модуля</em> не имеет никаких ссылок на другую часть этого <em>модуля</em>, то эти части можно разделить на разные модули. Если модули могут меняться независимо, то разделить нужно.</p></blockquote><p>Начинать стоит с простого: если можно отделить – надо отделить. Необходимо чтобы внутри одного модуля весь функционал был связан между собой (high cohesion, такое словосочетание вы наверное слышали). Принцип работает только в одну сторону: если подмножество A некоторого модуля не имеет ссылок на подмножество B, то это не значит что B не имеет ссылок на A, причем скорее всего именно B будет ссылаться на A.</p><p>Следуя данному принципу весь код будет распадаться на множество маленьких модулей, многие из которых выродятся до одной функции. Это нормально, даже хорошо. Функции потом можно группировать в модули по логической связности, добиваясь все того же high cohesion.</p><p>Модули будут зависеть друг от друга, они будут выстраиваться в ориентированный граф. Расположив зависимости сверху вниз можно условно разделить модули на <em>верхне-</em> и <em>нижне-</em> <em>уровневые</em>. На самом “пространство”, в котором мы пытаемся упорядочить модули, многомерно. Придумать одно отношение порядка для всего этого пространства невозможно. Но для двух модулей, между которыми есть путь, можно сказать какой из них верхнеуровневый, а какой нижнеуровневый. </p><p>Зависимость между модулями может быть:</p><ol><li><em>Ссылочной</em>, когда модуль A непосредственно обращается к модулю B, его функциям и данным. </li>
<li><em>Наследованием</em>, когда модуль A является частным случаем B. </li>
<li><em>Зависимостью по состоянию</em>, когда два модуля оперируют одним внешним состоянием (глобальные переменные, файлы, БД) и влияют на работу друг друга. Это плохая зависимость, от нее надо избавляться. </li>
<li><em>Зависимостью по времени</em>. Когда для работы требуется одного модуля требуется вызов функций другого модуля в нужные моменты. Это самый плохой вид зависимости, он него надо избавляться однозначно всеми возможными способами. </li>
</ol><h5>&#160;</h5><h5>Далее <em>ISP</em></h5><p>Как я уже писал выше, если следовать <em>SRP, </em>то программа распадется на множество мелких модулей. <em>ISP</em> говорит нам что это хорошо. Далее когда занимаетесь объединением отдельных функций в некоторые модули по смысловой связности, то учитывайте также <em>ISP</em>, не создавая модулей с очень жирным интерфейсом.</p><p>&#160;</p><h5>Перейдем к <em>DIP</em></h5><p>Этот принцип говорит нам что для двух <em>ссылочно</em> связанных <em>модулей</em> надо создавать <em>абстрактный интерфейс</em>. Оформлять <em>модуль,</em> от которого зависят другие <em>модули,</em> в виде <em>класса</em>, реализующего данный <em>абстрактный интерфейс</em>. Зависимый модуль должен обращаться к <em>абстрактному интерфейсу</em>, а не к конкретному <em>классу</em>. (low coupling, тоже слышали)</p><p>Есть проблема в том что надо создавать экземпляры <em>классов</em>, чтобы потом их передавать в зависимые <em>модули</em>. Эту проблему решают IoC-контейнеры, о которых я <a href="http://gandjustas.blogspot.com/2009/01/ioc.html" target="_blank">писал ранее</a>.</p><p>&#160;</p><h5>Теперь рассмотрим <em>LSP</em></h5><p>Принцип подстановки Барбары Лисков сформулирован предельно формально и говорит вообще о любых типа, а не только классах ООП.</p><blockquote><p>Если A является подтипом B, то в любом месте программы (функции), где требуется объект типа B, можно подставить объект типа A и поведение программы (функции) при этом не изменится.</p></blockquote><p>В ООП если <em>класс</em> A унаследован от <em>класса</em> B, равно как <em>класс</em> A реализует <em>абстрактный интерфейс</em> B, то A является <em>подтипом</em> B, а B является <em>супертипом</em> A.&#160; Кроме того некоторые языки программирования поддерживают <a href="http://gandjustas.blogspot.com/2009/11/blog-post.html" target="_blank">вариантность типов</a>, для них тоже надо применять <em>LSP</em>, но там помогает компилятор.</p><p>Принцип LSP надо использовать максимально широко, надо ориентироваться на весь <em>контракт</em>, в том числе пред- и пост-условия, а также то что не описано в самой программе.</p><p>Для контрактов правила простые:</p><ol><li>Предусловия в <em>подтипе</em> должны быть <strong>не сильнее,</strong> чем в <em>супертипе</em>. </li>
<li>Постусловия в <em>подтипе</em> должны быть <strong>не слабее</strong>, чем в <em>супертипе</em>. </li>
<li>Перечень выбрасываемых исключений в <em>подтипе</em> должен быть <strong>не шире</strong>, чем в <em>супертипе</em>. (хотя часто на это не обращают внимания) </li>
<li>Остальные детали контракта, которые нельзя проверить статически, должны проверяться тестами, и <em>подтипы</em> должны проходить все тесты, которые проходят <em>супертипы</em>. </li>
</ol><p>&#160;</p><h5>Напоследок <em>OCP</em></h5><p>Хорошо понимая <em>LSP</em> легко сообразить о чем говорит OCP.</p><blockquote><p>Все не-sealed классы должны быть спроектированы таким образом, чтобы наследники не могли нарушить <em>LSP</em>.</p></blockquote><p>Ну вот и все.</p><h4>Что не вошло в пятерку</h4><h5>Принцип бритвы Оккма</h5><blockquote><p>Не плодите сущности без нужды</p></blockquote><p>После активного применения SRP у вас будет много маленьких модулей, вплоть до одиночных функций. Тривиальные функции можно непосредственно инлайнить в вызывающий код, простые функции также можно перенести, если они используются только в одном месте. Отдельные функции можно объединять в модули по смысловому назначению, а также по параметрам, задавая их на уровне модуля, а не отдельных функций.</p><h5>Do not repeat yourself (<em>DRY</em>)</h5><p>Одинаковый или похожий код должен быть вынесен в отдельный модуль и использован другими. Для этого сильно помогают инструменты <a href="http://gandjustas.blogspot.com/2011/04/unity-20-interception.html" target="_blank">вроде IoC-контейнеров с возможностью AOP.</a></p><h5>Command-Query Separation (<em>CQS</em>)</h5><p>Все функции некоторого <em>интерфейса </em>должны быть или некоторыми <strong>запросами</strong>, возвращающими ответ, или <strong>командами</strong>, изменяющими состояние системы, <em>но не одновременно</em>. Никогда функция не должна возвращать ответ и изменять состояние системы одновременно.</p><p>Пожалуйста не путайте этот принцип с модным нынче CQRS, который является гипертрофированным CQS для непонятно каких целей.</p><p><strong>Keep it simple, stupid! (<em>KISS</em>)</strong></p><blockquote><p>Делайте все настолько простыми, насколько можно, но не проще.</p></blockquote><p>Создавайте ровно те модули, которые необходимы для решения задач, если модуль не решает задачу – не создавайте его. Если вы хотите создать модуль, но толком не представляете какую задачу он решает – не создавайте его. Если при переделке программы модули стали ненужным – удалите их.&#160; Если в некоторых поведение системы не описано для некоторых входных данных - не делайте частные случаи, опишите явно контракт, который запретит неверные данные.</p><p><font size="2"></font></p><h4>Заключение</h4><p>Самыми важными принципами в начале проектирования частей программы являются <em>KISS</em> и <em>SRP.</em> После того как появился некоторый граф модулей надо сразу применять <em>Бритву Оккама</em>,<em> LSP</em>,<em> ISP</em>. Когда начинаете писать код, то применяйте <em>DRY</em>, <em>DIP</em>, <em>CQS</em> и <em>OCP</em>.</p><p>Ну вот теперь совсем все.</p></cut>