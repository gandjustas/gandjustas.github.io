---
layout: post
title: "Применимость DDD"
date: '2011-12-12T10:00:00.000+04:00'
author: "Станислав Выщепан"
tags:
- "архитектура"
- DDD
modified_time: '2011-12-12T10:00:10.015+04:00'
blogger_id: tag:blogger.com,1999:blog-1302241583051203640.post-7141352374966561775
blogger_orig_url: http://blog.gandjustas.ru/2011/12/ddd.html
redirect_from: /2011/12/ddd.html
---

<p>До сих пор не утихают холивары на тему DDD\rich vs anemic. С одной стороны апологеты DDD (domain driven design, дизайн на основе предметной области) твердят о том как это круто, с другой стороны говоря что оно не везде подходит. На вопрос где же оно подходит обычно затрудняются ответить или отвечают “for compex domain”, причем примеров применения такого встретить непросто.</p>  <a name='more'></a>  <p>&#160;</p>  <p>Попробуем разобраться. Если отбросить всю философскую шелуху DDD, то придем к очень простой концепции жирной (rich, насыщенной) модели, <a href="http://martinfowler.com/eaaCatalog/domainModel.html" target="_blank">описанной Фаулером</a>. С одной стороны Фаулер предлагает поместить логику в классы “сущностей”, соответствующие данным предметной области. С другой стороны он прекрасно понимает что логика будет сложна и надо каким-то образом декомпозировать её. Кроме того есть логика, которая оперирует более чем одной сущностью и поместить её в один из классов сущностей не выгодно. Таким образом создаются классы сервисов, стратегий итп. Их всех объединяет свойство, что они не содержат данные предметной области и для работы обращаются к классам сущностей. По сути вся сложная логика располагается в этих самых сервисах. </p>  <p>По мере увеличения сложности логики программы количество сервисов, стратегий и других классов не-сущностей растет, увеличивается связность. Кроме того жирная модель имеет тенденцию вытягивать много данных из внешнего хранилища для работы, поэтому по мере усложнения еще и быстродействие начинает страдать. </p>  <p>Тут стоит отступить назад и посмотреть на общую картину. Как выглядит код приложения, использующий жирную модель (на основе модели в статье Фаулера):</p>  <pre class="brush: csharp;">class ContractsController
{
    public Result CalculateRecognitionsAction(int contractId)
    {
        var contract = repository.GetById(contractId);
        contract.CalculateRecognitions();
        repository.Save();
    }
}</pre>

<p><strong>Contract.CalculateRecognitions</strong> свою очередь выглядит как-то так:</p>

<pre class="brush: csharp;">public void CalculateRecognitions()
{
    this.Product.CalculateRecognitions(this);
}</pre>

<p>А <strong>Product.CalculateRecognitions</strong> выглядит так:</p>

<pre class="brush: csharp;">public void CalculateRecognitions(Contract c)
{
    var recognitions = recognitionService.CalculateRecognitions(this);
    c.SetRecognitions(recognitions);
}</pre>

<p>Теперь попробуем выполнить простое преобразование: на верхнем уровне будем вызывать сервис, а не методы сущностей.</p>

<pre class="brush: csharp;">class ContractsController
{
    public Result CalculateRecognitionsAction(int contractId)
    {
        var p = repository.GetProductByContractId(contractId);
        var recognitions = recognitionsService.CalculateRecognitions(p);
        repository.SaveRecognitionsForContract(contractId, recognitions);
    }
}</pre>

<p>Такой код меньше по объему, имеет меньшую связность межу классами, от этого он более гибок и лучше подается оптимизации.</p>

<h5>Сдвиг предмета моделирования</h5>

<p>Если посмотреть какие концептуальные изменения произошли в коде в примере выше, то становится понятно что центральным объектом у нас стал RecognitionsService, а не Contract. То есть вместо <em>модели исходных данных</em> (<em>предметной области</em>) задачи мы начали использовать <em>модель решения</em> этой задачи. Модели исходных данных никуда не делась, просто её роль в решении стала гораздо меньше. Такая модель называется стройной (<em>anemic</em>).</p>

<p>Очевидно что <em>модель решения задачи</em> для решения задачи подходит лучше чем <em>модель исходных данных</em> задачи. Ведь моделировать <em>экскаватор</em> правильнее чем писать <em>земля.Копайся() </em>(спасибо за метафору <a href="http://www.rsdn.ru/Users/5743.aspx" target="_blank">Sinclair</a>). Причем чем сложнее задача, тем выгоднее строить модель решения, а не исходных данных (предметной области). </p>

<p>Таким образом DDD не подходит для сложных задач.</p>

<h5>Лирическое отступление</h5>

<p>Если вы думаете что вынося всю логику из класса Product в ProductService\ProductHelper\ProductManager вы получаете модель решения, то вы жестоко ошибаетесь. Фактически это будет DDD, только в худшем его проявлении.</p>

<h4></h4>

<p><strong></strong></p>

<h5>Сложные предметные области</h5>

<p>Но все же стоит рассмотреть случай сложной предметной области. Когда исходные данные связаны между собой нетривиальными отношениями, которые надо поддерживать независимо от операций, которые производятся с данными предметной области. При этом сама предметная область состоит из множества разных типов.</p>

<p>В такой ситуации вроде как DDD должен рулить со страшной силой, так как все правила будут упрятаны в сами сущности и не будет снаружи путей нарушить их. Фактически проверки будут срабатывать на изменение свойств.</p>

<p>Но если подойти с точки зрения моделирования решения, то становится понятно что надо проверять правила не при любом изменении свойства, а при попытке записать эти изменения во внешнее хранилище. Для этого можно создавать классы валидаторы, которые будут вызываться в репозитарии (роль которого может играть ORM).</p>

<p>И снова такое решение гораздо боле гибкое,чем жирная модель. Эти же валидаторы можно приспособить для валидации ввода пользователя, для возвращения ему осмысленных ошибок, а не исключений. Кроме того можно предусмотреть сохранение “черновиков” во внешнем хранилище, которые не проходят всех правил. </p>

<h5>Так где же область применимости DDD?</h5>

<p>Как не удивительно, но DDD хорошо работает на <em>простых задачах</em>, там где нет необходимости разделять систему на слои, уменьшать связность путем выноса логики в отдельные стратегии итд. В простых задачах<em> модель исходных данных</em> <em>(предметной области)</em> и <em>модель решения</em> почти совпадают.</p>

<p>Например взять блог. Обычный блог как например этот. Моделью предметной области являются: блог, посты, комменты, страницы, виджеты в интерфейсе. Решение включает в себя функции: создать пост, изменить пост, удалить пост, получить список, поменять настройки блога. Все эти функции вполне можно поместить в класс Блога, а умный ORM разберется как потом все изменения положить в БД.</p>

<h5>Но почему DDD столь популярен?</h5>

<p>Именно потому что DDD хорошо работает на простых примерах. Ведь в книгах и презентациях невозможно привести пример на 20kloc. А на примерах в 100 строк DDD выглядит очевидно и очень привлекательно.</p>

<p>Другая причина заключается в том что DDD это не только подход к проектированию, но это еще и подход к анализу. Именно с точки зрения анализа DDD показывает себя хорошо. Предлагает некоторый системный подход к анализу требований, выделению областей, взаимному обучению экспертов со стороны заказчика и разработчика.</p>

<h5>Заключение</h5>

<p>Не стоит слепо следовать DDD. У догматичного DDD очень узкая область применения. Старайтесь моделировать решение задачи, не зацикливайтесь на моделировании исходных данных. Всегда оценивайте как то или иное решение повлияет на качество кода безотносительно DDD, ООП или других баззвордов.</p>  
