---
layout: post
title: "Об обработчиках событий элементов списка"
date: '2011-05-31T01:15:00.001+04:00'
author: "Станислав Выщепан"
tags:
- SharePoint
modified_time: '2011-05-31T01:20:16.396+04:00'
blogger_id: tag:blogger.com,1999:blog-1302241583051203640.post-4749049714414570390
blogger_orig_url: http://blog.gandjustas.ru/2011/05/blog-post.html
redirect_from: /2011/05/blog-post.html
---

<p>Обработчики событий элементов списка&nbsp; это классы, унаследованные от <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventreceiver.aspx" target="_blank">SPItemEventReceiver</a>. В классе содержится много методов, почти все они делятся на две группы: Pre-события – методы, оканчивающиеся на -ing, и Post-события – методы, оканчивающиеся на -ed. Все события принимают один аргумент экземпляр класса <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.aspx" target="_blank">SPItemEventProperties</a>. </p> <p>Это теоретический минимум, который необходимо знать для начала.</p> <h4>Коварные AfterProperties и BeforeProperties</h4> <p>Класс <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.aspx">SPItemEventProperties</a> содержит пару свойств: <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.afterproperties.aspx" target="_blank">AfterProperties</a> и <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.beforeproperties.aspx" target="_blank">BeforeProperties</a>. На первый взгляд очень хорошие свойства, которые позволяют с небольшими усилиями реализовать множество сценариев. Но на деле все не так…</p> <ol> <li>Для начала необходимо запомнить, а потом распечатать и повесить на стену, на холодильник, да доску и на все остальные поверхности следующие таблицы: <br> <table border="1" cellspacing="0" cellpadding="2"> <tbody> <tr> <td valign="top"><em>Список</em></td> <td valign="top"><strong>BeforeProperties</strong></td> <td valign="top"><strong>AfterProperties</strong></td> <td valign="top"><strong>properties.ListItem</strong></td></tr> <tr> <td valign="top">ItemAdding</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Новые значения</td> <td valign="top" align="center">null</td></tr> <tr> <td valign="top">ItemAdded</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Новые значения</td> <td valign="top" align="center">Новые значения</td></tr> <tr> <td valign="top">ItemUpdating</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Новые значения</td> <td valign="top" align="center">Старые значения</td></tr> <tr> <td valign="top">ItemUpdated</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Новые значения</td> <td valign="top" align="center">Новые значения</td></tr> <tr> <td valign="top">ItemDeleting</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Старые значения</td></tr> <tr> <td valign="top">ItemDeleted</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">null</td></tr></tbody></table><br> <table border="1" cellspacing="0" cellpadding="2"> <tbody> <tr> <td valign="top"><em>Библиотека</em></td> <td valign="top"><strong>BeforeProperties</strong></td> <td valign="top"><strong>AfterProperties</strong></td> <td valign="top"><strong>properties.ListItem</strong></td></tr> <tr> <td valign="top">ItemAdding</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">null</td></tr> <tr> <td valign="top">ItemAdded</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Новые значения</td></tr> <tr> <td valign="top">ItemUpdating</td> <td valign="top" align="center">Старые значения</td> <td valign="top" align="center">Новые значения</td> <td valign="top" align="center">Старые значения</td></tr> <tr> <td valign="top">ItemUpdated</td> <td valign="top" align="center">Старые значения</td> <td valign="top" align="center">Новые значения</td> <td valign="top" align="center">Новые значения</td></tr> <tr> <td valign="top">ItemDeleting</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Старые значения</td></tr> <tr> <td valign="top">ItemDeleted</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">Пусто</td> <td valign="top" align="center">null</td></tr></tbody></table><br>Поведение списков и библиотек документов разное и отличается от предполагаемого. <br>Как видите из таблиц выше, BeforeProperties почти бесполезное свойство. <br> <li><a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.afterproperties.aspx">AfterProperties</a> и <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.beforeproperties.aspx">BeforeProperties</a> содержат свойство <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventdatacollection.changedproperties.aspx" target="_blank">ChangedProperties</a>. Это свойство показывает измененные поля в самой коллекции, а не в элементе.  <li>Свойство-индексатор <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.afterproperties.aspx">AfterProperties</a> и <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.beforeproperties.aspx">BeforeProperties</a> принимает Internal Name поля, а не Display Name как в properties.ListItem.  <li><a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.afterproperties.aspx">AfterProperties</a> и <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.beforeproperties.aspx">BeforeProperties</a> поддерживают нетипизированный <a href="http://msdn.microsoft.com/EN-US/library/system.collections.ienumerable(v=VS.90)" target="_blank">IEnumerable</a>, но нигде в документации не указано какого типа возвращается перечисление. Опыты показывают что возвращается <a href="http://msdn.microsoft.com/en-us/library/system.collections.dictionaryentry(v=VS.90).aspx" target="_blank">DictionaryEntry</a>.  <li><a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.afterproperties.aspx">AfterProperties</a> и <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.beforeproperties.aspx">BeforeProperties</a> возвращают все значения в виде строк. Кроме того для boolean типа поля может быт возвращено "-1" в качестве значения, а строки возвращаются в универсальном формате и при парсинге автоматически переводятся в текущую локаль (+3 часа обычно получается).  <li>При изменении элемента списка в коде в <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.afterproperties.aspx">AfterProperties</a> попадают только измененные значения, а при сохранении формы – все значения формы.  <li>При сохранении формы с RichText полем в <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.afterproperties.aspx">AfterProperties</a> попадает HTML со всеми заглавными буквами в названиях тегов. </li></ol> <h4>Отмена действия</h4> <blockquote> <p>Pre-события позволяют отменить действие. Для этого необходимо в <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.speventpropertiesbase.cancel.aspx" target="_blank">properties.Cancel</a> присвоить true, присвоить необходимые значения свойствам <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.speventpropertiesbase.status.aspx" target="_blank">properties.Status</a> и <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.speventpropertiesbase.errormessage.aspx" target="_blank">properties.ErrorMessage</a>. Но и тут есть особенности:</p></blockquote> <ol> <li>Если вы собираетесь отменить действие, то не вызывайте базовую реализацию метода-обработчика. Иначе отмена не произойдет.  <li>Если вы поставите статус CancelWithError, то будет выкинуто стандартное исключение, которое в режиме отладки отображается желтым экраном смерти.  <li>Если хотите показать свое сообщение об ошибке, то сделайте CancelWithRedirect, но учтите что в таком случае управление не вернется к вызывающему коду.  <li>Если необходимо выполнение разных способов отмены, то анализируйте <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spcontext.aspx" target="_blank">SPContext</a> и его свойства <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spcontext.formcontext.aspx" target="_blank">FormContext</a> и <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spcontext.viewcontext.aspx" target="_blank">ViewContext</a>.  <li>Отмена работает всегда, для любой учетной записи, в том числе системной. Желательно позволять выполнять действие (не отменять его) администратору коллекции сайтов и учетной записи "SHAREPOINT\system". </li></ol> <h4>Конкурентное выполнение обработчиков событий</h4> <p>В <a href="http://blogs.msdn.com/b/sharepointdev/archive/2011/05/30/sharepoint-foundation-2010-events-pipeline.aspx" target="_blank">этом посте</a> описан пайплайн обработки событий, картинка ниже кратко его иллюстрирует. <img src="http://blogs.msdn.com/cfs-file.ashx/__key/CommunityServer-Blogs-Components-WeblogFiles/00-00-01-40-86-metablogapi/8372.SharePoint_5F00_Foundation_5F00_2010_5F00_Events_5F00_Pipeline_5F00_thumb_5F00_2A3C65B2.png"></p> <p>Как видно обработчики Post-событий могут запускаться параллельно. Если будут параллельно запускаться несколько обработчиков, изменяющих сам элемент, то может появиться состояние гонки. <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spcontext.item.aspx" target="_blank">Класс SPListItem</a> снабжен механизмом так называемой “оптимистичной конкуренции”. В случая если другой потом успел поменять значение в базе между моментом считывания и записью данных, то выпадет исключение. Но исключения в пост-обработчиках не очень эффективны, так как нет возможности как-либо сигнализировать об ошибке, если только это не синхронный обработчик.</p> <ol> <li>По возможности не изменяйте элемент списка из асинхронного пост-обработчика.  <li>Перехватывайте <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.splistdatavalidationexception.aspx" target="_blank">SPListDataValidationException</a>. Если поймали такое исключение, то выполните <a href="http://msdn.microsoft.com/en-us/library/microsoft.sharepoint.spitemeventproperties.invalidatelistitem.aspx" target="_blank">properties.InvalidateListItem</a>, а потом снова код обновления элемента.  <li>Используйте следующий блок кода в пост-обработчиках, чтобы не вызвать их циклического запуска <br><pre class="brush: csharp;">try
{
    this.EventFiringEnabled = false;
    //...здесь вызов Update...
}
finally
{
    this.EventFiringEnabled = true;
}</pre>
<li>Также можно использовать SystemUpdate, чтобы не вызывать обработчики событий и не менять время последнего изменения элемента.<pre></pre></li></ol><br>К сожалению это далеко не все грабли, которые встречаются при обработке событий. С прочими граблями можно ознакомиться тут:<a href="http://msdn.microsoft.com/en-us/library/aa979520.aspx">http://msdn.microsoft.com/en-us/library/aa979520.aspx</a>  
