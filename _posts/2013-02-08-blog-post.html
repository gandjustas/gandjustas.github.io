---
layout: post
title: "Стратегия кеширования в приложении"
date: '2013-02-08T11:00:00.000+04:00'
author: "Станислав Выщепан"
tags: 
modified_time: '2013-02-08T11:00:04.374+04:00'
blogger_id: tag:blogger.com,1999:blog-1302241583051203640.post-3004507826812300397
blogger_orig_url: http://blog.gandjustas.ru/2013/02/blog-post.html
---

<p>Когда заходит разговор о кешировании складывается парадоксальная ситуация. С одной стороны все понимают важность и нужность кеширования в архитектуре приложений. С другой стороны мало кто может внятно объяснить&nbsp; <em>что</em> и <em>как</em> надо кешировать. </p> <p>Обычно люди сходу начинают предлагать готовые реализации кеша, вроде memcached или HTTP-кеша, но это лишь ответ на вопрос <em>где</em> кешировать.</p> <p>Кеширование – одна из многих тем, наряду с безопасностью и логированием, о которых знают и говорят все, но мало кто может это сделать правильно. </p> <h3>Зачем нужен кеш</h3> <p>Кеш приближает данные к месту их использования. В современном мире, состоящим на 98% из интернета, данные обычно лежат очень далеко от пользователя. На всем пути от хранилища к пользователю есть кеши, которые служат только одной цели – чтобы пользователь как можно быстрее получил свои данные.</p> <p>Если рассмотреть внимательнее, то видно, что драгоценное время тратится на обработку данных в поставщике и передачу данных от поставщика клиенту, время обработки данных на клиенте тут не учитываем.</p> <p>При наличии высоких нагрузок кеширование просто необходимо. Оно позволяет обслуживать больше клиентов, с теми же ресурсами, потому что поставщики данных больше отдыхают. Но даже при невысоких нагрузках кеширование положительно влияет на отзывчивость приложения.</p> <h3>Кеш нельзя просто включить</h3> <p>Одно из основных заблуждений насчет кеширования заключается в том, что многие думают что кеш можно просто включить. </p> <p>На заре своей карьеры программиста я один раз просто так включил кеширование, буквально через час пришлось его выключить. Тогда я нарвался на основную проблему при кешировании –<em> устаревание данных</em>. Пользователь после изменения данных не видел результата 15 минут.</p> <p>Очень важно понимать что и как вы собираетесь кешировать, чтобы не нарушать логику работы приложения. И первый вопрос, на который вам необходимо ответить – насколько устаревшие данные можно отдавать клиенту.&nbsp; Естественно можно сделать свой кеш для каждого клиента, это упростит решение вопроса об актуальности данных, но принесет много других проблем.</p> <h3>Типы кеширования</h3> <p>Есть три основных типа кеширования по механике работы:</p> <ul> <li>Lazy cache , он же <em>ленивый кеш</em>, он же <em>тупой кеш</em> – самый простой в реализации тип кеширования, зачастую встроен в фреймворки. Кеш просто сохраняет данные и отдает их пока не устареет. </li> <li>Synchronized cache, <em>синхронизированный кеш</em> – клиент вместе с данными получается метку последнего изменения и может спросить у поставщика не изменились ли данные, чтобы повторно из не запрашивать. Такой тип кеширования позволяет всегда иметь свежие данные, но очень сложен в реализации.</li> <li>Write-through cache, или <em>кеш сквозной записи</em> – любое изменение данных выполняется сразу в хранилище и в кеше. Этот тип кеша может никогда не устаревать, но возникают проблемы с так называемой “<a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B3%D0%B5%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%BA%D1%8D%D1%88%D0%B0" target="_blank"><em>когерентностью</em></a>”.</li></ul> <p>Наверное можно придумать и другие типы кешей, но я не встречал.</p> <h3>Устаревание и когерентность кеша</h3> <p>Объем кеша всегда ограничен. Зачастую он меньше объема данных, которые в этот кеш можно положить. Поэтому элементы, помещенные в кеш, рано или поздно будут вытеснены. Современные фреймворки для кеширования позволяют очень гибко управлять устареванием, учитывая приоритеты, время устаревания, объемы данных итд.</p> <p>Если одни и те же данные попадают в разные кеши, то возникает проблема <em>когерентности</em> кеша. Например одни и те же данные используются для формирования разных страниц и кешируются страницы. Страницы сформированные позже будут содержать обновленные данные, а страницы, закешированные раньше, будут содержать устаревшие данные. Таким образом будет нарушена согласованность поведения.</p> <p>Простой способ поддержания когерентности – принудительное устаревание (сброс) кеша при изменении данных. Поэтому увеличение памяти для кеша, чтобы он меньше устаревал, не всегда хорошая идея.</p> <h3>Эффективность кеша</h3> <p>Основной параметр, который характеризует систему кеширования – это <em>процент попаданий запросов в кеш</em>. Этот параметр довольно легко измерить, чтобы понять насколько ваша система кеширования эффективна.</p> <p>Частые сбросы кеша, кеширование редко запрашиваемых данных, недостаточный объем кеша – все это ведет к пустой трате оперативной (обычно) памяти, не повышая эффективность работы.</p> <p>Иногда данные меняются настолько часто и непредсказуемо, что кеширование не даст эффекта, процент попаданий будет близок к нулю. Но обычно данные считываются гораздо чаще, чем записываются, поэтому кеши эффективны.</p> <h3>Применение разных типов кеширования</h3> <h4>Ленивый кеш</h4> <p>Это самый простой вид кеширования, но его нужно использовать осторожно, так как отдает устаревшие данные. Можно при каждой записи сбрасывать ленивый кеш, чтобы поддерживать актуальность данных, но тогда затраты на реализацию будут сравнимы с более сложными типами кеширования.</p> <p>Такой тип кеширования можно использовать для данных, которые почти никогда не меняются. Другой вариант использования – делать ленивый кеш с небольшим временем устаревания для стабильной работы при всплесках нагрузки.</p> <p>Такой тип кеширования позволит быстрее всех дать ответ.</p> <h4>Синхронизированный кеш</h4> <p>Это самый полезный тип кеширования, так как отдает свежие данные и позволяет реализовать многоуровневый кеш. </p> <p>Такой тип кеширования встроен в протокол HTTP. Сервер отдает метку изменения, а клиент кеширует у тебя результат и в последующем запросе передает эту метку. Сервер может дать ответ, что состояние не изменилось и можно использовать кешированный на клиенте объект. Сервер в свою очередь, получив метку может переспросить у хранилища были ли изменения или нет. </p> <p>Этот тип кеширования не избавляет от накладных расходов на общение между системами. Поэтому часто дополняется другими типами кеширования, чтобы ускорить работу.</p> <h4>Кеш сквозной записи</h4> <p>Если есть система распределенного кеширования (memcached, Windows Sever App Fabric, Azure Cache), то можно использовать кеш сквозной записи. Рукопашная реализация синхронизации кешей между узлами сама по себе отдельный большой проект, потому не стоит заниматься ей в рамках разработки приложения. </p> <p>Не стоит пытаться кешировать все в синхронизированном кеше, иначе большая часть кода приложения будет заниматься перестройкой кеша.</p> <p>Также не стоит забывать что системы распределенного кеширования также требуют общения между системами, что может сказываться на быстродействии.</p> <h3>Что еще нужно учитывать в стратегии кеширования</h3> <p>Выбирайте правильную гранулярность кешируемых данных. Например кеширование данных для каждого пользователя скорее всего будет неэффективно при большом количестве пользователей. Если кешировать данные всех пользователей, то возникнут проблемы с устареванием данных и когерентностью кеша. </p> <p>Кешируйте данные как можно позже, непосредственно перед отдачей во внешнюю систему. Кешировать данные, полученные извне, необходимо только в случае проблем с производительностью на этом этапе. Внешние хранилища, такие как СУБД и файловые системы, сами реализуют кеширование, поэтому обычно нет смысла кешировать результаты запросов.</p> <p>Не нужно городить свои велосипеды для кеширования в приложениях, обычно уже есть готовые инструменты и надо уметь ими пользоваться.</p> <h3>Заключение</h3> <p>Надеюсь статья была интересной и полезной для вас. Комментируйте, оценивайте, буду рад любым предложениям.</p>  