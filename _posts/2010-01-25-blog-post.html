---
layout: post
title: "История одного маппера"
date: '2010-01-25T17:16:00.001+03:00'
author: "Станислав Выщепан"
tags:
- mapping
- ".NET"
- Expression Mapper
modified_time: '2010-01-26T11:15:23.886+03:00'
blogger_id: tag:blogger.com,1999:blog-1302241583051203640.post-2970913859002931316
blogger_orig_url: http://blog.gandjustas.ru/2010/01/blog-post.html
redirect_from: /2010/01/blog-post.html
---

<p>Однажды холодным зимним вечером я читал блог <a href="http://bradwilson.typepad.com/blog/" target="_blank">Brad Wilson</a>, а именно вот <a href="http://bradwilson.typepad.com/blog/2010/01/input-validation-vs-model-validation-in-aspnet-mvc.html" target="_blank">эту статью</a> и понял что нужно писать View-specific models для ASP.NET приложения. Основная проблема с написанием таких моделей заключается в том что приходится писать много “водопроводного кода” для маппинга сущностей базы, возвращаемых ORM на эти самые модели и наоборот. Причем Linq (если поддерживает ORM) позволяет описывать прямое преобразование, но не обратное.</p>  <p>Я начал искать object-to-object мапперы. Сразу нашел <a href="http://automapper.codeplex.com/" target="_blank">AutoMapper</a>, он меня отпугнул монструозностью конфигурации и жутко неудобным (<em>читай</em> <em>статическим</em>) API использования. Кроме того отзывы о скорости работы этого маппера крайне негативные.</p>  <p>Следующим мне на глаза попался <a href="http://emitmapper.codeplex.com/" target="_blank">EmitMapper</a>. Гораздо более приятный API для использования и довольно высокая скорость работы за счет кодогенерации. Но настройка и кастомизация выполняется очень многословно и непонятно.</p>  <p>В обоих проектах меня не устроил тяжелый API для маппинга. По сути маппинг из типа A в тип B - не более чем функция&#160; A → B, или в нотации типов C# - Func&lt;A,B&gt;.</p>  <p>Я сел писать свой маппер. Естественно для скорости надо заниматься кодогенерацией, но писать свой кодогенератор в несколько килострок кода времени не хватит и проект будет заброшен. Но, к счастью, в .NET начиная с версии 3.5 есть кодогенератор и AST для него. Это классы наследники <a href="http://msdn.microsoft.com/en-us/library/system.linq.expressions.expression.aspx" target="_blank">Expression</a> из пространства имен <strong>System.Linq.Expressions</strong>, а компилятор тихо сидит в методе <a href="http://msdn.microsoft.com/en-us/library/bb345362.aspx" target="_blank">Expression&lt;T&gt;.Compile</a>.</p>  <p>Таким образом задача упрощается до безобразия. Необходимо собрать expression tree и скомпилировать его. За два вечера я написал маппер, который поддерживает маппинг массивов, списков, сложных типов, конфигурацию с помощью expression tree и flattering.</p>  <p>Результаты сего труда я залил на Codeplex. Проект назвал <a href="http://expressionmapper.codeplex.com/" target="_blank">Expression Mapper</a>.</p>  <h4>Скорость работы мапппера.</h4>  <p>Пока писал маппер нашел <a href="http://habrahabr.ru/blogs/net/80793/" target="_blank">бенчмарк на хабре</a>. Решил прогнать свой маппер на таком бенчмарке. Результаты немного поразили:</p>  <p>Handwritten Mapper: 88 milliseconds    <br />Emit Mapper: 157 milliseconds     <br />Auto Mapper: 31969 milliseconds     <br />Expression Mapper: 119 milliseconds</p>  <h4>Недостатки.</h4>  <p>Кроме того что проект еще сырой и требует доработки есть еще один серьезный недостаток. Нету возможности сделать маппер, который не создает новый объект, а изменяет поля в существующем.</p>  <p>Ссылка на страницу проекта - <a title="http://expressionmapper.codeplex.com/" href="http://expressionmapper.codeplex.com/">http://expressionmapper.codeplex.com/</a></p>  
